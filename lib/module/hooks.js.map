{"version":3,"names":["Children","useState","useCallback","useContext","useEffect","StyleSheet","cancelAnimation","useAnimatedReaction","useAnimatedRef","useAnimatedScrollHandler","useSharedValue","withDelay","withTiming","interpolate","Extrapolate","runOnJS","runOnUI","useDerivedValue","useEvent","useHandler","Context","TabNameContext","IS_IOS","ONE_FRAME_MS","scrollToImpl","useContainerRef","useAnimatedDynamicRefs","map","setMap","setRef","key","ref","useTabProps","children","tabType","options","tabOptions","Map","forEach","element","index","type","Error","name","props","has","set","opts","optionKeys","Array","from","keys","useTabsContext","raw","c","useTabNameContext","useCollapsibleStyle","headerHeight","tabBarHeight","containerHeight","width","allowHeaderOverscroll","containerHeightVal","tabBarHeightVal","headerHeightVal","useConvertAnimatedToValue","style","contentContainerStyle","minHeight","paddingTop","progressViewOffset","useUpdateScrollViewContentSize","tabNames","contentHeights","setContentHeights","height","tabIndex","value","indexOf","scrollContentSizeChange","_","h","useChainCallback","fns","callAll","args","fn","useScroller","contentInset","scroller","x","y","animated","_debugKey","useScrollHandlerY","accDiffClamp","focusedTab","snapThreshold","revealHeaderOnScroll","refMap","scrollYCurrent","scrollY","oldAccScrollY","accScrollY","offset","headerScrollDistance","snappingTo","indexDecimal","enabled","enable","toggle","afterDrag","findIndex","n","scrollTo","scrollAnimation","undefined","val","onMomentumEnd","contentHeight","Number","MAX_VALUE","scrollHandler","onScroll","event","contentOffset","clampMax","CLAMP","delta","nextValue","Math","min","max","onBeginDrag","onEndDrag","duration","isFinished","onMomentumBegin","isChangingPane","isInteger","isSyncNeeded","wasSyncNeeded","nextPosition","focusedScrollY","round","tabScrollY","areEqual","currIsOnTop","hairlineWidth","focusedIsOnTop","hasGap","useSharedAnimatedRef","outerRef","current","useAfterMountEffect","effect","didExecute","setDidExecute","timeout","setTimeout","clearTimeout","animatedValue","setValue","animValue","useHeaderMeasurements","headerTranslateY","top","useCurrentTabScrollY","useFocusedTab","tabsContext","focusedTabValue","useAnimatedTabIndex","usePageScrollHandler","handlers","dependencies","context","doDependenciesDiffer","subscribeForEvents","onPageScroll","eventName","endsWith"],"sources":["hooks.tsx"],"sourcesContent":["import {\n  Children,\n  useState,\n  useCallback,\n  useContext,\n  MutableRefObject,\n  useEffect,\n  DependencyList,\n} from 'react'\nimport { StyleSheet } from 'react-native'\nimport { ContainerRef, RefComponent } from 'react-native-collapsible-tab-view'\nimport { PagerViewOnPageScrollEvent } from 'react-native-pager-view'\nimport Animated, {\n  cancelAnimation,\n  useAnimatedReaction,\n  useAnimatedRef,\n  useAnimatedScrollHandler,\n  useSharedValue,\n  withDelay,\n  withTiming,\n  interpolate,\n  Extrapolate,\n  runOnJS,\n  runOnUI,\n  useDerivedValue,\n  useEvent,\n  useHandler,\n} from 'react-native-reanimated'\n\nimport { Context, TabNameContext } from './Context'\nimport { IS_IOS, ONE_FRAME_MS, scrollToImpl } from './helpers'\nimport {\n  CollapsibleStyle,\n  ContextType,\n  TabName,\n  TabReactElement,\n  TabsWithProps,\n  Ref,\n} from './types'\n\nexport function useContainerRef() {\n  return useAnimatedRef<ContainerRef>()\n}\n\nexport function useAnimatedDynamicRefs(): [\n  ContextType['refMap'],\n  ContextType['setRef']\n] {\n  const [map, setMap] = useState<ContextType['refMap']>({})\n  const setRef = (key: TabName, ref: React.RefObject<any>) => {\n    setMap((map) => ({ ...map, [key]: ref }))\n    return ref\n  }\n\n  return [map, setRef]\n}\n\nexport function useTabProps<T extends TabName>(\n  children: TabReactElement<T>[] | TabReactElement<T>,\n  tabType: Function\n): [TabsWithProps<T>, T[]] {\n  const options = () => {\n    const tabOptions: TabsWithProps<T> = new Map()\n    if (children) {\n      Children.forEach(children, (element, index) => {\n        if (!element) return\n\n        if (element.type !== tabType)\n          throw new Error(\n            'Container children must be wrapped in a <Tabs.Tab ... /> component'\n          )\n\n        // make sure children is excluded otherwise our props will mutate too much\n        const { name, children, ...options } = element.props\n        if (tabOptions.has(name))\n          throw new Error(`Tab names must be unique, ${name} already exists`)\n\n        tabOptions.set(name, {\n          index,\n          name,\n          ...options,\n        })\n      })\n    }\n    return tabOptions\n  }\n  const opts = options()\n  const optionKeys = Array.from(opts.keys())\n  return [opts, optionKeys]\n}\n\n/**\n * Hook exposing some useful variables.\n *\n * ```tsx\n * const { focusedTab, ...rest } = useTabsContext()\n * ```\n */\nexport function useTabsContext(raw?: boolean): ContextType<TabName> | null {\n  const c = useContext(Context)\n  if (!c) {\n    if (raw) {\n      return null\n    }\n    throw new Error('useTabsContext must be inside a Tabs.Container')\n  }\n  return c\n}\n\n/**\n * Access the parent tab screen from any deep component.\n *\n * ```tsx\n * const tabName = useTabNameContext()\n * ```\n */\nexport function useTabNameContext(): TabName {\n  const c = useContext(TabNameContext)\n  if (!c) throw new Error('useTabNameContext must be inside a TabNameContext')\n  return c\n}\n\n/**\n * Hook to access some key styles that make the whole thing work.\n *\n * You can use this to get the progessViewOffset and pass to the refresh control of scroll view.\n */\nexport function useCollapsibleStyle(): CollapsibleStyle {\n  const {\n    headerHeight,\n    tabBarHeight,\n    containerHeight,\n    width,\n    allowHeaderOverscroll,\n  } = useTabsContext()!\n  const [containerHeightVal, tabBarHeightVal, headerHeightVal] = [\n    useConvertAnimatedToValue(containerHeight),\n    useConvertAnimatedToValue(tabBarHeight),\n    useConvertAnimatedToValue(headerHeight),\n  ]\n  return {\n    style: { width },\n    contentContainerStyle: {\n      minHeight:\n        IS_IOS && !allowHeaderOverscroll\n          ? (containerHeightVal || 0) - (tabBarHeightVal || 0)\n          : (containerHeightVal || 0) + (headerHeightVal || 0),\n      paddingTop:\n        IS_IOS && !allowHeaderOverscroll\n          ? 0\n          : (headerHeightVal || 0) + (tabBarHeightVal || 0),\n    },\n    progressViewOffset:\n      // on iOS we need the refresh control to be at the top if overscrolling\n      IS_IOS && allowHeaderOverscroll\n        ? 0\n        : // on android we need it below the header or it doesn't show because of z-index\n          (headerHeightVal || 0) + (tabBarHeightVal || 0),\n  }\n}\n\nexport function useUpdateScrollViewContentSize({ name }: { name: TabName }) {\n  const { tabNames, contentHeights } = useTabsContext()!\n  const setContentHeights = useCallback(\n    (name: TabName, height: number) => {\n      const tabIndex = tabNames.value.indexOf(name)\n      contentHeights.value[tabIndex] = height\n      contentHeights.value = [...contentHeights.value]\n    },\n    [contentHeights, tabNames]\n  )\n\n  const scrollContentSizeChange = useCallback(\n    (_: number, h: number) => {\n      runOnUI(setContentHeights)(name, h)\n    },\n    [setContentHeights, name]\n  )\n\n  return scrollContentSizeChange\n}\n\n/**\n * Allows specifying multiple functions to be called in a sequence with the same parameters\n * Useful because we handle some events and need to pass them forward so that the caller can handle them as well\n * @param fns array of functions to call\n * @returns a function that once called will call all passed functions\n */\nexport function useChainCallback(fns: (Function | undefined)[]) {\n  const callAll = (...args: unknown[]) => {\n    fns.forEach((fn) => {\n      if (typeof fn === 'function') {\n        fn(...args)\n      }\n    })\n  }\n  return callAll\n}\n\nexport function useScroller<T extends RefComponent>() {\n  const { contentInset } = useTabsContext()!\n\n  const scroller = (\n    ref: Ref<T> | undefined,\n    x: number,\n    y: number,\n    animated: boolean,\n    _debugKey: string\n  ) => {\n    'worklet'\n    if (!ref) return\n    //! this is left here on purpose to ease troubleshooting (uncomment when necessary)\n    // console.log(\n    //   `${_debugKey}, y: ${y}, y adjusted: ${y - contentInset.value}`\n    // )\n    scrollToImpl(ref, x, y - contentInset.value, animated)\n  }\n\n  return scroller\n}\n\nexport const useScrollHandlerY = (name: TabName) => {\n  const {\n    accDiffClamp,\n    focusedTab,\n    snapThreshold,\n    revealHeaderOnScroll,\n    refMap,\n    tabNames,\n    index,\n    headerHeight,\n    contentInset,\n    containerHeight,\n    scrollYCurrent,\n    scrollY,\n    oldAccScrollY,\n    accScrollY,\n    offset,\n    headerScrollDistance,\n    snappingTo,\n    contentHeights,\n    indexDecimal,\n    allowHeaderOverscroll,\n  } = useTabsContext()!\n\n  const enabled = useSharedValue(false)\n\n  const enable = useCallback(\n    (toggle: boolean) => {\n      enabled.value = toggle\n    },\n    [enabled]\n  )\n\n  /**\n   * Helper value to track if user is dragging on iOS, because iOS calls\n   * onMomentumEnd only after a vigorous swipe. If the user has finished the\n   * drag, but the onMomentumEnd has never triggered, we need to manually\n   * call it to sync the scenes.\n   */\n  const afterDrag = useSharedValue(0)\n\n  const tabIndex = tabNames.value.findIndex((n) => n === name)\n\n  const scrollTo = useScroller()\n\n  const scrollAnimation = useSharedValue<number | undefined>(undefined)\n\n  useAnimatedReaction(\n    () => scrollAnimation.value,\n    (val) => {\n      if (val !== undefined) {\n        scrollTo(refMap[name], 0, val, false, '[useAnimatedReaction scroll]')\n      }\n    }\n  )\n\n  const onMomentumEnd = () => {\n    'worklet'\n    if (!enabled.value) return\n\n    if (typeof snapThreshold === 'number') {\n      if (revealHeaderOnScroll) {\n        if (accDiffClamp.value > 0) {\n          if (\n            scrollYCurrent.value >\n            headerScrollDistance.value * snapThreshold\n          ) {\n            if (\n              accDiffClamp.value <=\n              headerScrollDistance.value * snapThreshold\n            ) {\n              // snap down\n              accDiffClamp.value = withTiming(0)\n            } else if (accDiffClamp.value < headerScrollDistance.value) {\n              // snap up\n              accDiffClamp.value = withTiming(headerScrollDistance.value)\n\n              if (scrollYCurrent.value < headerScrollDistance.value) {\n                scrollAnimation.value = scrollYCurrent.value\n                scrollAnimation.value = withTiming(headerScrollDistance.value)\n                //console.log('[${name}] sticky snap up')\n              }\n            }\n          } else {\n            accDiffClamp.value = withTiming(0)\n          }\n        }\n      } else {\n        if (\n          scrollYCurrent.value <=\n          headerScrollDistance.value * snapThreshold\n        ) {\n          // snap down\n          snappingTo.value = 0\n          scrollAnimation.value = scrollYCurrent.value\n          scrollAnimation.value = withTiming(0)\n          //console.log('[${name}] snap down')\n        } else if (scrollYCurrent.value <= headerScrollDistance.value) {\n          // snap up\n          snappingTo.value = headerScrollDistance.value\n          scrollAnimation.value = scrollYCurrent.value\n          scrollAnimation.value = withTiming(headerScrollDistance.value)\n          //console.log('[${name}] snap up')\n        }\n      }\n    }\n  }\n\n  const contentHeight = useDerivedValue(() => {\n    const tabIndex = tabNames.value.indexOf(name)\n    return contentHeights.value[tabIndex] || Number.MAX_VALUE\n  }, [])\n\n  const scrollHandler = useAnimatedScrollHandler(\n    {\n      onScroll: (event) => {\n        if (!enabled.value) return\n\n        if (focusedTab.value === name) {\n          if (IS_IOS) {\n            let { y } = event.contentOffset\n            // normalize the value so it starts at 0\n            y = y + contentInset.value\n            const clampMax =\n              contentHeight.value -\n              (containerHeight.value || 0) +\n              contentInset.value\n            // make sure the y value is clamped to the scrollable size (clamps overscrolling)\n            scrollYCurrent.value = allowHeaderOverscroll\n              ? y\n              : interpolate(y, [0, clampMax], [0, clampMax], Extrapolate.CLAMP)\n          } else {\n            const { y } = event.contentOffset\n            scrollYCurrent.value = y\n          }\n\n          scrollY.value[index.value] = scrollYCurrent.value\n          oldAccScrollY.value = accScrollY.value\n          accScrollY.value = scrollY.value[index.value] + offset.value\n\n          if (revealHeaderOnScroll) {\n            const delta = accScrollY.value - oldAccScrollY.value\n            const nextValue = accDiffClamp.value + delta\n            if (delta > 0) {\n              // scrolling down\n              accDiffClamp.value = Math.min(\n                headerScrollDistance.value,\n                nextValue\n              )\n            } else if (delta < 0) {\n              // scrolling up\n              accDiffClamp.value = Math.max(0, nextValue)\n            }\n          }\n        }\n      },\n      onBeginDrag: () => {\n        if (!enabled.value) return\n\n        // ensure the header stops snapping\n        cancelAnimation(accDiffClamp)\n\n        if (IS_IOS) cancelAnimation(afterDrag)\n      },\n      onEndDrag: () => {\n        if (!enabled.value) return\n\n        if (IS_IOS) {\n          // we delay this by one frame so that onMomentumBegin may fire on iOS\n          afterDrag.value = withDelay(\n            ONE_FRAME_MS,\n            withTiming(0, { duration: 0 }, (isFinished) => {\n              // if the animation is finished, the onMomentumBegin has\n              // never started, so we need to manually trigger the onMomentumEnd\n              // to make sure we snap\n              if (isFinished) {\n                onMomentumEnd()\n              }\n            })\n          )\n        }\n      },\n      onMomentumBegin: () => {\n        if (!enabled.value) return\n\n        if (IS_IOS) {\n          cancelAnimation(afterDrag)\n        }\n      },\n      onMomentumEnd,\n    },\n    [\n      refMap,\n      name,\n      revealHeaderOnScroll,\n      containerHeight,\n      contentInset,\n      snapThreshold,\n      enabled,\n      scrollTo,\n    ]\n  )\n\n  // sync unfocused scenes\n  useAnimatedReaction(\n    () => {\n      if (!enabled.value) {\n        return false\n      }\n\n      // if the index is decimal, then we're in between panes\n      const isChangingPane = !Number.isInteger(indexDecimal.value)\n\n      return isChangingPane\n    },\n    (isSyncNeeded, wasSyncNeeded) => {\n      if (\n        isSyncNeeded &&\n        isSyncNeeded !== wasSyncNeeded &&\n        focusedTab.value !== name\n      ) {\n        let nextPosition = null\n        const focusedScrollY = scrollY.value[Math.round(indexDecimal.value)]\n        const tabScrollY = scrollY.value[tabIndex]\n        const areEqual = focusedScrollY === tabScrollY\n\n        if (!areEqual) {\n          const currIsOnTop =\n            tabScrollY + StyleSheet.hairlineWidth <= headerScrollDistance.value\n          const focusedIsOnTop =\n            focusedScrollY + StyleSheet.hairlineWidth <=\n            headerScrollDistance.value\n\n          if (revealHeaderOnScroll) {\n            const hasGap = accDiffClamp.value > tabScrollY\n            if (hasGap || currIsOnTop) {\n              nextPosition = accDiffClamp.value\n            }\n          } else if (typeof snapThreshold === 'number') {\n            if (focusedIsOnTop) {\n              nextPosition = snappingTo.value\n            } else if (currIsOnTop) {\n              nextPosition = headerHeight.value || 0\n            }\n          } else if (currIsOnTop || focusedIsOnTop) {\n            nextPosition = Math.min(focusedScrollY, headerScrollDistance.value)\n          }\n        }\n\n        if (nextPosition !== null) {\n          // console.log(`sync ${name} ${nextPosition}`)\n          scrollY.value[tabIndex] = nextPosition\n          scrollTo(refMap[name], 0, nextPosition, false, `[${name}] sync pane`)\n        }\n      }\n    },\n    [revealHeaderOnScroll, refMap, snapThreshold, tabIndex, enabled, scrollTo]\n  )\n\n  return { scrollHandler, enable }\n}\n\ntype ForwardRefType<T> =\n  | ((instance: T | null) => void)\n  | MutableRefObject<T | null>\n  | null\n\n/**\n * Magic hook that creates a multicast ref. Useful so that we can both capture the ref, and forward it to callers.\n * Accepts a parameter for an outer ref that will also be updated to the same ref\n * @param outerRef the outer ref that needs to be updated\n * @returns an animated ref\n */\nexport function useSharedAnimatedRef<T extends RefComponent>(\n  outerRef: ForwardRefType<T>\n) {\n  const ref = useAnimatedRef<T>()\n\n  // this executes on every render\n  useEffect(() => {\n    if (!outerRef) {\n      return\n    }\n    if (typeof outerRef === 'function') {\n      outerRef(ref.current)\n    } else {\n      outerRef.current = ref.current\n    }\n  })\n\n  return ref\n}\n\nexport function useAfterMountEffect(effect: React.EffectCallback) {\n  const [didExecute, setDidExecute] = useState(false)\n  useEffect(() => {\n    if (didExecute) return\n\n    const timeout = setTimeout(() => {\n      effect()\n      setDidExecute(true)\n    }, 0)\n    return () => {\n      clearTimeout(timeout)\n    }\n  }, [didExecute, effect])\n}\n\nexport function useConvertAnimatedToValue<T>(\n  animatedValue: Animated.SharedValue<T>\n) {\n  const [value, setValue] = useState(animatedValue.value)\n\n  useAnimatedReaction(\n    () => {\n      return animatedValue.value\n    },\n    (animValue) => {\n      if (animValue !== value) {\n        runOnJS(setValue)(animValue)\n      }\n    },\n    [value]\n  )\n\n  return value\n}\n\nexport interface HeaderMeasurements {\n  /**\n   * Animated value that represents the current Y translation of the header\n   */\n  top: Animated.SharedValue<number>\n  /**\n   * Animated value that represents the height of the header\n   */\n  height: Animated.SharedValue<number | undefined>\n}\n\nexport function useHeaderMeasurements(): HeaderMeasurements {\n  const { headerTranslateY, headerHeight } = useTabsContext()!\n  return {\n    top: headerTranslateY,\n    height: headerHeight,\n  }\n}\n\n/**\n * Returns the vertical scroll position of the current tab as an Animated SharedValue\n */\nexport function useCurrentTabScrollY(): Animated.SharedValue<number> {\n  const { scrollYCurrent } = useTabsContext()!\n  return scrollYCurrent\n}\n\n/**\n * Returns the currently focused tab name\n */\nexport function useFocusedTab(raw?: boolean) {\n  const tabsContext = useTabsContext(raw)\n  if (!tabsContext) {\n    return ''\n  }\n  const { focusedTab } = tabsContext\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const focusedTabValue = useConvertAnimatedToValue(focusedTab)\n  return focusedTabValue\n}\n\n/**\n * Returns an animated value representing the current tab index, as a floating point number\n */\nexport function useAnimatedTabIndex() {\n  const { indexDecimal } = useTabsContext()!\n  return indexDecimal\n}\n\nexport const usePageScrollHandler = (\n  handlers: {\n    onPageScroll: (\n      event: PagerViewOnPageScrollEvent['nativeEvent'],\n      context: unknown\n    ) => unknown\n  },\n  dependencies?: DependencyList\n) => {\n  const { context, doDependenciesDiffer } = useHandler(handlers, dependencies)\n  const subscribeForEvents = ['onPageScroll']\n\n  return useEvent<any>(\n    (event) => {\n      'worklet'\n      const { onPageScroll } = handlers\n      if (onPageScroll && event.eventName.endsWith('onPageScroll')) {\n        onPageScroll(event, context)\n      }\n    },\n    subscribeForEvents,\n    doDependenciesDiffer\n  )\n}\n"],"mappings":"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"}